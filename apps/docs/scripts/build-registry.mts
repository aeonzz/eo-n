import { existsSync, promises as fs } from "node:fs";
import { tmpdir } from "node:os";
import path from "node:path";
import { cwd } from "node:process";
import { rimraf } from "rimraf";
import { Project, ScriptKind, SyntaxKind } from "ts-morph";
import type { z } from "zod";

import { components } from "@/registry/registry-components";
import { examples } from "@/registry/registry-examples";
import { lib } from "@/registry/registry-lib";
import { themes } from "@/registry/registry-themes";
import { ui } from "@/registry/registry-ui";

import { baseColors } from "../registry/registry-base-colors";
import { colorMapping, colors } from "../registry/registry-colors";
import { styles } from "../registry/registry-styles";
import {
  registryEntrySchema,
  registrySchema,
  type Registry,
  type RegistryEntry,
  type registryItemTypeSchema,
} from "../registry/schema";
import { fixImport } from "./fix-imports.mjs";

export const registry: Registry = [
  ...ui,
  ...lib,
  ...themes,
  ...examples,
  ...components,
];

const REGISTRY_PATH = path.join(process.cwd(), "public/r");

const REGISTRY_INDEX_WHITELIST: z.infer<typeof registryItemTypeSchema>[] = [
  "registry:ui",
  "registry:lib",
  "registry:hook",
  "registry:theme",
  "registry:block",
  "registry:example",
  "registry:component",
];

const project = new Project({
  compilerOptions: {},
});

async function createTempSourceFile(filename: string) {
  const dir = await fs.mkdtemp(path.join(tmpdir(), "shadcn-"));
  return path.join(dir, filename);
}

/**
 * A simple template function that replaces <%- variable %> with values from the data object
 * @param template The template string containing <%- variable %> placeholders
 * @returns A function that takes a data object and returns the interpolated string
 */
function createTemplate(template: string) {
  return (data: Record<string, unknown>) => {
    return template.replace(/<%-(.*?)%>/g, (_match: string, key: string) => {
      const props = key.trim().split(".");
      let value: unknown = data;
      for (const prop of props) {
        value = (value as Record<string, unknown>)?.[prop];
      }
      return String(value ?? "");
    });
  };
}

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: Registry) {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {
`;

  for (const style of styles) {
    index += `  "${style.name}": {`;

    // Build style index.
    for (const item of registry) {
      const resolveFiles = item.files?.map(
        (file) =>
          `registry/${style.name}/${
            typeof file === "string" ? file : file.path
          }`
      );
      if (!resolveFiles) {
        continue;
      }

      const type = item.type.split(":")[1];
      let sourceFilename = "";

      // biome-ignore lint/suspicious/noExplicitAny: <explanation>
      let chunks: any = [];
      if (item.type === "registry:block") {
        const file = resolveFiles[0];
        const filename = path.basename(file);
        let raw: string;
        try {
          raw = await fs.readFile(file, "utf8");
        } catch (_error) {
          continue;
        }
        const tempFile = await createTempSourceFile(filename);
        const sourceFile = project.createSourceFile(tempFile, raw, {
          scriptKind: ScriptKind.TSX,
        });

        const description = sourceFile
          .getVariableDeclaration("description")
          ?.getInitializerOrThrow()
          .asKindOrThrow(SyntaxKind.StringLiteral)
          .getLiteralValue();

        item.description = description ?? "";

        // Find all imports.
        const imports = new Map<
          string,
          {
            module: string;
            text: string;
            isDefault?: boolean;
          }
        >();
        for (const node of sourceFile.getImportDeclarations()) {
          const module = node.getModuleSpecifier().getLiteralValue();
          for (const item of node.getNamedImports()) {
            imports.set(item.getText(), {
              module,
              text: node.getText(),
            });
          }

          const defaultImport = node.getDefaultImport();
          if (defaultImport) {
            imports.set(defaultImport.getText(), {
              module,
              text: defaultImport.getText(),
              isDefault: true,
            });
          }
        }

        // Find all opening tags with x-chunk attribute.
        const components = sourceFile
          .getDescendantsOfKind(SyntaxKind.JsxOpeningElement)
          .filter((node) => {
            return node.getAttribute("x-chunk") !== undefined;
          });

        chunks = await Promise.all(
          components.map(async (component, index) => {
            const chunkName = `${item.name}-chunk-${index}`;

            // Get the value of x-chunk attribute.
            const attr = component
              .getAttributeOrThrow("x-chunk")
              .asKindOrThrow(SyntaxKind.JsxAttribute);

            const description = attr
              .getInitializerOrThrow()
              .asKindOrThrow(SyntaxKind.StringLiteral)
              .getLiteralValue();

            // Delete the x-chunk attribute.
            attr.remove();

            // Add a new attribute to the component.
            component.addAttribute({
              name: "x-chunk",
              initializer: `"${chunkName}"`,
            });

            // Get the value of x-chunk-container attribute.
            const containerAttr = component
              .getAttribute("x-chunk-container")
              ?.asKindOrThrow(SyntaxKind.JsxAttribute);

            const containerClassName = containerAttr
              ?.getInitializer()
              ?.asKindOrThrow(SyntaxKind.StringLiteral)
              .getLiteralValue();

            containerAttr?.remove();

            const parentJsxElement = component.getParentIfKindOrThrow(
              SyntaxKind.JsxElement
            );

            // Find all opening tags on component.
            const children = parentJsxElement
              .getDescendantsOfKind(SyntaxKind.JsxOpeningElement)
              .map((node) => {
                return node.getTagNameNode().getText();
              })
              .concat(
                parentJsxElement
                  .getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement)
                  .map((node) => {
                    return node.getTagNameNode().getText();
                  })
              );

            const componentImports = new Map<
              string,
              string | string[] | Set<string>
            >();
            for (const child of children) {
              const importLine = imports.get(child);
              if (importLine) {
                const imports = componentImports.get(importLine.module) || [];

                const newImports = importLine.isDefault
                  ? importLine.text
                  : new Set([...imports, child]);

                componentImports.set(
                  importLine.module,
                  importLine?.isDefault ? newImports : Array.from(newImports)
                );
              }
            }

            const componnetImportLines = Array.from(
              componentImports.keys()
            ).map((key) => {
              const values = componentImports.get(key);
              const specifier = Array.isArray(values)
                ? `{${values.join(",")}}`
                : values;

              return `import ${specifier} from "${key}"`;
            });

            const code = `
            'use client'

            ${componnetImportLines.join("\n")}

            export default function Component() {
              return (${parentJsxElement.getText()})
            }`;

            const targetFile = file.replace(item.name, `${chunkName}`);
            const targetFilePath = path.join(
              cwd(),
              `registry/${style.name}/${type}/${chunkName}.tsx`
            );

            // Write component file.
            rimraf.sync(targetFilePath);
            await fs.writeFile(targetFilePath, code, "utf8");

            return {
              name: chunkName,
              description,
              component: `React.lazy(() => import("@/registry/${style.name}/${type}/${chunkName}")),`,
              file: targetFile,
              container: {
                className: containerClassName,
              },
            };
          })
        );

        // // Write the source file for blocks only.
        sourceFilename = `__registry__/${style.name}/${type}/${item.name}.tsx`;

        if (item.files) {
          const files = item.files.map((file) =>
            typeof file === "string"
              ? { type: "registry:page", path: file }
              : file
          );
          if (files?.length) {
            sourceFilename = `__registry__/${style.name}/${files[0].path}`;
          }
        }

        const sourcePath = path.join(process.cwd(), sourceFilename);
        if (!existsSync(sourcePath)) {
          await fs.mkdir(sourcePath, { recursive: true });
        }

        rimraf.sync(sourcePath);
        await fs.writeFile(sourcePath, sourceFile.getText());
      }

      let componentPath = `@/registry/${style.name}/${type}/${item.name}`;

      if (item.files) {
        const files = item.files.map((file) =>
          typeof file === "string"
            ? { type: "registry:page", path: file }
            : file
        );
        if (files?.length) {
          componentPath = `@/registry/${style.name}/${files[0].path}`;
        }
      }

      index += `
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${item.files?.map((file) => {
        const filePath = `registry/${style.name}/${
          typeof file === "string" ? file : file.path
        }`;
        const resolvedFilePath = path.resolve(filePath);
        return typeof file === "string"
          ? `"${resolvedFilePath}"`
          : `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`;
      })}],
      component: React.lazy(() => import("${componentPath}")),
      source: "${sourceFilename}",
      category: "${item.category ?? ""}",
      subcategory: "${item.subcategory ?? ""}",
      chunks: [${chunks.map(
        (chunk: any) => `{
        name: "${chunk.name}",
        description: "${chunk.description ?? "No description"}",
        component: ${chunk.component}
        file: "${chunk.file}",
        container: {
          className: "${chunk.container.className}"
        }
      }`
      )}]
    },`;
    }

    index += `
  },`;
  }

  index += `
}
`;

  // ----------------------------------------------------------------------------
  // Build registry/index.json.
  // ----------------------------------------------------------------------------
  const items = registry
    .filter((item) => ["registry:ui"].includes(item.type))
    .map((item) => {
      return {
        ...item,
        files: item.files?.map((_file) => {
          const file =
            typeof _file === "string"
              ? {
                  path: _file,
                  type: item.type,
                }
              : _file;

          return file;
        }),
      };
    });
  const registryJson = JSON.stringify(items, null, 2);
  rimraf.sync(path.join(REGISTRY_PATH, "index.json"));
  await fs.writeFile(
    path.join(REGISTRY_PATH, "index.json"),
    registryJson,
    "utf8"
  );

  // Write style index.
  rimraf.sync(path.join(process.cwd(), "__registry__/index.tsx"));
  await fs.writeFile(path.join(process.cwd(), "__registry__/index.tsx"), index);
}


try {
  const result = registrySchema.safeParse(registry);

  if (!result.success) {
    console.error(result.error);
    process.exit(1);
  }

  await buildRegistry(result.data);

  console.log("âœ… Done!");
} catch (error) {
  console.error(error);
  process.exit(1);
}
